(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["phaseShiftSolver`"]
solverDE::usage="solverDE[DE, \[CapitalPsi]s, {x, min}, p] uses NDSolve to solve eigenvalue problems that asymptotically reduce to plane wave systems with eigenvalue p. It returns a matrix of solutions for \[CapitalPsi]s at positions in the interval [min, min+3\!\(\*FractionBox[\(2  \[Pi]\), \(p\)]\)].  ";
fitExp::usage="fitExp[data,p][x] fits the data with exponentials:
	C[1] Exp[\[ImaginaryI] p x] + C[2] Exp[-\[ImaginaryI] p x] ";
findRealPhase::usage="findRealPhase[data,p] returns the phase from fitExp, assuming its coefficients are real.";
findComplexPhase::usage="findComplexPhase[data,p] returns the phase from fitExp, assuming its coefficients are imaginary.";
dataNoJump::usage="dataNoJump[data] returns the data without \[Pi] jumps";
phaseTable::usage="phaseTable[DE,\[CapitalPsi]s,{x,xmin},{p,pRange}][[i]] returns a list of phases for the given range of ps for \[CapitalPsi]s[[i]]. Note: xmin should be large enough such that xmin*p>>1, which is the limit where the phase-shift method works. ";
pPhaseTable::usage="pPhaseTable[DE,\[CapitalPsi]s,{x,xmin},{p,pRange}][[i]] returns a list of {p, phase} for \[CapitalPsi]s[[i]]. Note: xmin should be large enough such that xmin*p>>1, which is the limit where the phase-shift method works.";
testFitting::usage="testFitting[DE,\[Phi],{x,min},p] shows the plot of the numeric result and the fit with the derived phaseshift.";

Begin["`Private`"]
Needs["commons`"]


(* ::Input::Initialization:: *)
solverDE[DE_,\[CapitalPsi]s_List,{x_?notNumericQ,min_?NumericQ},p_?NumericQ]:=Module[{len,waveL,max,steps,interpolations,X,Y},
waveL=N[(2\[Pi])/p];max=min+3waveL;steps=3waveL/50.;
len=Length@\[CapitalPsi]s;
interpolations=\[CapitalPsi]s/.Flatten@NDSolve[DE,\[CapitalPsi]s,{x,min,max}, Method->"StiffnessSwitching"];
X=Range[min,max,steps];
Y=mapParallel[interpolations,X];
Transpose@{X,#}&/@Y
]

(**************************************************************************************)
fitExp[data_List,p_?NumericQ][x_]:=Fit[data,{Exp[I  p x],Exp[-I p x ]},x];

findRealPhase[data_List,p_?NumericQ]:=Module[{a,x},
{a}=Coefficient[fitExp[data,p][x],{Exp[I p x]}];
Arg[a]
]

findComplexPhase[data_List,p_?NumericQ]:=Module[{a,b,x},
{a,b}=Coefficient[fitExp[data,p][x],{Exp[I  p x], Exp[-I p x ]}];
ArcTan[(a+b),-I (a-b)]//Chop
]
(**************************************************************************************)

dataNoJump[phaseData_List]:=Module[{delta,count,phaseDataN,l,sign,i},
l=Length@phaseData;
phaseDataN=Table[0,{i,1,l}];
phaseDataN[[1]]=phaseData[[1]];
For[i=2,i <= l,i++,
delta=phaseData[[i]]-phaseDataN[[i-1]];
count= Round[delta/\[Pi]];
If[count!=0,phaseDataN[[i]]=phaseData[[i]]-count \[Pi],phaseDataN[[i]]=phaseData[[i]]]];
Return[phaseDataN];
]

(**************************************************************************************)
(* 
Note: phase-shift works for x*p>>1, however, fixing the product for varying p is not good numerically. 
This is because the error of the phase-shift is O(1/x), see WKB analysis, then, if we fix x*p = const, then x=const/p, hence the error of the phase-shift will be O(p). 
Instead, I will let xmin to be fixed by the user such that xmin*p>>1 
*)

phaseTable[DE_,\[CapitalPsi]s_List,{x_?notNumericQ, xmin_?NumericQ},{p_?notNumericQ,pRange_List}]:=Module[
{data},
(* data[[i]] are solutions for different \[CapitalPsi]s[[i]]*)
Table[
data=solverDE[DE,\[CapitalPsi]s,{x,xmin},p];
findRealPhase[#,p]&/@data,
{p,pRange}]//Transpose
]


pPhaseTable[DE_,\[CapitalPsi]s_List,{x_?notNumericQ,xmin_?NumericQ},{p_?notNumericQ,pRange_List}]:=Module[
{phaseData,phaseDataContinuous},
phaseData=phaseTable[DE,\[CapitalPsi]s,{x,xmin},{p,pRange}];
phaseDataContinuous=dataNoJump[#]&/@phaseData;
Transpose@{pRange,#}&/@phaseDataContinuous
]

(**************************************************************************************)
testFitting[DE_,\[Phi]_List,{x_?notNumericQ,min_?NumericQ},p_?NumericQ]:=Module[{phaseShift,waveL,max,data},
waveL=N[(2\[Pi])/p];max=min+3waveL;
data=solverDE[DE,\[Phi],{x,min},p][[1]]; (* choose just the first solution for the test *)

phaseShift=findComplexPhase[data,p];

Show[ListPlot@data,Plot[Max@data[[;;,2]]Cos[p x+phaseShift],{x,min,max }]]

]



(* ::Input::Initialization:: *)
End[]
EndPackage[]



