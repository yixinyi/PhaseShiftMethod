(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["WKB`"]
WKBsolutions::usage="WKBsolutions[order][do, params][x], where order determines the WKB expansion Exp[\[ImaginaryI] \!\(\*FractionBox[\(1\), \(e\)]\)(\!\(\*SubscriptBox[\(S\), \(0\)]\)(x)+ e \!\(\*SubscriptBox[\(S\), \(1\)]\)(x)+...+ \!\(\*SuperscriptBox[\(e\), \(order\)]\) \!\(\*SubscriptBox[\(S\), \(order\)]\)(x))],
and do is the differential operator, x is the variable. 
The output will be the solutions for the 1st derivatives of \!\(\*SubscriptBox[\(S\), \(i\)]\)(x). 
Note that PowerExpand is used to improve the speed!
";

Begin["`Private`"]
Needs["commons`"]


(* ::Input::Initialization:: *)
WKBsolutions[order_Integer][do_,params_List][x_?notNumericQ]:=Module[{e,ansatz,listS, listDerivS,eq,componentsEq,series,solutionDerivS},
(* WKB ansatz and {S0[x], S1[x], ...} *)
{ansatz,listS}=WKBansatz[order,e,x];

(* {S0'[x], S1'[x], ...} *)
listDerivS=D[#,x]&/@listS;

(* plug in the ansatz to the differential equation with the eigenvalue part, the final equation will be equated to 0 *)
eq=do@ansatz/ansatz//Simplify;

(* expand the differential equation for large p, we subtract 2 because it's a 2nd order DE *)
series=Series[eq/.listsToRule[params,params/e],{e,0,order-2}]; 
componentsEq=(List@@LogicalExpand[series==0])//PowerExpand//Simplify;

(* solve for the derivatives of Subscript[S, i] in terms of Subscript[S, j] with j<i *)
solutionDerivS=Collect[Solve[componentsEq,listDerivS]//Simplify//PowerExpand,params,Simplify];

(* replace 2nd derivatives of Subscript[S, i], note there are 2 sets of solutions *)
replace2ndDeriv[#,params,x]&/@solutionDerivS
]

WKBansatz[order_Integer,e_?notNumericQ,x_?notNumericQ]:=Module[{list, arg,ansatz},
(* {S0[x], S1[x], ...} *)
list=Table[ToExpression["S"<>ToString@i][x],{i,0,order}];
(* argument expanded in small e *)
arg=list.Table[Power[e,i],{i,-1,order-1}];
(* WKB ansatz *)
ansatz=Exp[I arg];
{ansatz,list}
]

replace2ndDeriv[list_List,params_List,x_?notNumericQ]:=Module[{solution,rule,ans,len,i},
(* the input list is of form {Subscript[S, i]'[x] \[Rule] in terms of derivatives of Subscript[S, j], j<i, for all i} *)
(* The first component is already good *)
solution={list[[1]]};
(* Replace the 2nd derivatives by the derivatives of the solution list *)
len=Length@list;
For[i=2,i<=len,i++,
rule=D[#,x]&/@solution;
ans=list[[i]]/.rule;
solution=Append[solution,ans];
];
Collect[solution,params,Simplify]
]


(* ::Input::Initialization:: *)
End[]
EndPackage[]



